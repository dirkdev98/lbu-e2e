// Generated by @lbu/code-gen
/* eslint-disable no-unused-vars */

export const validatorHooks = {};

const isNil = (value) => value === undefined || value === null;

/**
 * This function should not throw as the corresponding validator will do that
 * @callback ValidationErrorFn
 * @param {string} key
 * @param {Object} info
 */

/**
 * @type ValidationErrorFn
 */
let _errorBuildFn = (key, info) => {
  const err = new Error(`ValidationError: ${key}`);
  err.key = key;
  err.info = info;
  return err;
};

/**
 * Set a different error function, for example AppError.validationError
 * @param {ValidationErrorFn} fn
 */
export function validatorSetError(fn) {
  _errorBuildFn = fn;
}

function buildError(key, info) {
  throw _errorBuildFn(key, info);
}

export const lbuValidators = {
  /**
   *
   * @param {*} value
   * @param {string} [propertyPath]
   * @returns { LbuStructureResponse}
   */
  structureResponse: (value, propertyPath = "$") => {
    let result = value;
    if ("preValidateLbuStructureResponse" in validatorHooks) {
      result = validatorHooks["preValidateLbuStructureResponse"](result);
    }
    result = anyValidator0(result, propertyPath);
    if ("postValidateLbuStructureResponse" in validatorHooks) {
      return validatorHooks["postValidateLbuStructureResponse"](result);
    }
    return result;
  },
};

export const todoValidators = {
  /**
   *
   * @param {*} value
   * @param {string} [propertyPath]
   * @returns { TodoAllResponse}
   */
  allResponse: (value, propertyPath = "$") => {
    let result = value;
    if ("preValidateTodoAllResponse" in validatorHooks) {
      result = validatorHooks["preValidateTodoAllResponse"](result);
    }
    result = objectValidator1(result, propertyPath);
    if ("postValidateTodoAllResponse" in validatorHooks) {
      return validatorHooks["postValidateTodoAllResponse"](result);
    }
    return result;
  },

  /**
   *
   * @param {*} value
   * @param {string} [propertyPath]
   * @returns { TodoCollection}
   */
  collection: (value, propertyPath = "$") => {
    let result = value;
    if ("preValidateTodoCollection" in validatorHooks) {
      result = validatorHooks["preValidateTodoCollection"](result);
    }
    result = genericValidator3(result, propertyPath);
    if ("postValidateTodoCollection" in validatorHooks) {
      return validatorHooks["postValidateTodoCollection"](result);
    }
    return result;
  },

  /**
   *
   * @param {*} value
   * @param {string} [propertyPath]
   * @returns { TodoCreateItemBody}
   */
  createItemBody: (value, propertyPath = "$") => {
    let result = value;
    if ("preValidateTodoCreateItemBody" in validatorHooks) {
      result = validatorHooks["preValidateTodoCreateItemBody"](result);
    }
    result = objectValidator6(result, propertyPath);
    if ("postValidateTodoCreateItemBody" in validatorHooks) {
      return validatorHooks["postValidateTodoCreateItemBody"](result);
    }
    return result;
  },

  /**
   *
   * @param {*} value
   * @param {string} [propertyPath]
   * @returns { TodoCreateItemParams}
   */
  createItemParams: (value, propertyPath = "$") => {
    let result = value;
    if ("preValidateTodoCreateItemParams" in validatorHooks) {
      result = validatorHooks["preValidateTodoCreateItemParams"](result);
    }
    result = objectValidator8(result, propertyPath);
    if ("postValidateTodoCreateItemParams" in validatorHooks) {
      return validatorHooks["postValidateTodoCreateItemParams"](result);
    }
    return result;
  },

  /**
   *
   * @param {*} value
   * @param {string} [propertyPath]
   * @returns { TodoCreateItemResponse}
   */
  createItemResponse: (value, propertyPath = "$") => {
    let result = value;
    if ("preValidateTodoCreateItemResponse" in validatorHooks) {
      result = validatorHooks["preValidateTodoCreateItemResponse"](result);
    }
    result = objectValidator10(result, propertyPath);
    if ("postValidateTodoCreateItemResponse" in validatorHooks) {
      return validatorHooks["postValidateTodoCreateItemResponse"](result);
    }
    return result;
  },

  /**
   *
   * @param {*} value
   * @param {string} [propertyPath]
   * @returns { TodoDeleteParams}
   */
  deleteParams: (value, propertyPath = "$") => {
    let result = value;
    if ("preValidateTodoDeleteParams" in validatorHooks) {
      result = validatorHooks["preValidateTodoDeleteParams"](result);
    }
    result = objectValidator11(result, propertyPath);
    if ("postValidateTodoDeleteParams" in validatorHooks) {
      return validatorHooks["postValidateTodoDeleteParams"](result);
    }
    return result;
  },

  /**
   *
   * @param {*} value
   * @param {string} [propertyPath]
   * @returns { TodoDeleteResponse}
   */
  deleteResponse: (value, propertyPath = "$") => {
    let result = value;
    if ("preValidateTodoDeleteResponse" in validatorHooks) {
      result = validatorHooks["preValidateTodoDeleteResponse"](result);
    }
    result = objectValidator12(result, propertyPath);
    if ("postValidateTodoDeleteResponse" in validatorHooks) {
      return validatorHooks["postValidateTodoDeleteResponse"](result);
    }
    return result;
  },

  /**
   *
   * @param {*} value
   * @param {string} [propertyPath]
   * @returns { TodoItem}
   */
  item: (value, propertyPath = "$") => {
    let result = value;
    if ("preValidateTodoItem" in validatorHooks) {
      result = validatorHooks["preValidateTodoItem"](result);
    }
    result = objectValidator14(result, propertyPath);
    if ("postValidateTodoItem" in validatorHooks) {
      return validatorHooks["postValidateTodoItem"](result);
    }
    return result;
  },

  /**
   *
   * @param {*} value
   * @param {string} [propertyPath]
   * @returns { TodoList}
   */
  list: (value, propertyPath = "$") => {
    let result = value;
    if ("preValidateTodoList" in validatorHooks) {
      result = validatorHooks["preValidateTodoList"](result);
    }
    result = objectValidator16(result, propertyPath);
    if ("postValidateTodoList" in validatorHooks) {
      return validatorHooks["postValidateTodoList"](result);
    }
    return result;
  },

  /**
   *
   * @param {*} value
   * @param {string} [propertyPath]
   * @returns { TodoNewBody}
   */
  newBody: (value, propertyPath = "$") => {
    let result = value;
    if ("preValidateTodoNewBody" in validatorHooks) {
      result = validatorHooks["preValidateTodoNewBody"](result);
    }
    result = objectValidator19(result, propertyPath);
    if ("postValidateTodoNewBody" in validatorHooks) {
      return validatorHooks["postValidateTodoNewBody"](result);
    }
    return result;
  },

  /**
   *
   * @param {*} value
   * @param {string} [propertyPath]
   * @returns { TodoNewResponse}
   */
  newResponse: (value, propertyPath = "$") => {
    let result = value;
    if ("preValidateTodoNewResponse" in validatorHooks) {
      result = validatorHooks["preValidateTodoNewResponse"](result);
    }
    result = objectValidator20(result, propertyPath);
    if ("postValidateTodoNewResponse" in validatorHooks) {
      return validatorHooks["postValidateTodoNewResponse"](result);
    }
    return result;
  },

  /**
   *
   * @param {*} value
   * @param {string} [propertyPath]
   * @returns { TodoOneParams}
   */
  oneParams: (value, propertyPath = "$") => {
    let result = value;
    if ("preValidateTodoOneParams" in validatorHooks) {
      result = validatorHooks["preValidateTodoOneParams"](result);
    }
    result = objectValidator22(result, propertyPath);
    if ("postValidateTodoOneParams" in validatorHooks) {
      return validatorHooks["postValidateTodoOneParams"](result);
    }
    return result;
  },

  /**
   *
   * @param {*} value
   * @param {string} [propertyPath]
   * @returns { TodoOneResponse}
   */
  oneResponse: (value, propertyPath = "$") => {
    let result = value;
    if ("preValidateTodoOneResponse" in validatorHooks) {
      result = validatorHooks["preValidateTodoOneResponse"](result);
    }
    result = objectValidator23(result, propertyPath);
    if ("postValidateTodoOneResponse" in validatorHooks) {
      return validatorHooks["postValidateTodoOneResponse"](result);
    }
    return result;
  },

  /**
   *
   * @param {*} value
   * @param {string} [propertyPath]
   * @returns { TodoToggleItemBody}
   */
  toggleItemBody: (value, propertyPath = "$") => {
    let result = value;
    if ("preValidateTodoToggleItemBody" in validatorHooks) {
      result = validatorHooks["preValidateTodoToggleItemBody"](result);
    }
    result = objectValidator24(result, propertyPath);
    if ("postValidateTodoToggleItemBody" in validatorHooks) {
      return validatorHooks["postValidateTodoToggleItemBody"](result);
    }
    return result;
  },

  /**
   *
   * @param {*} value
   * @param {string} [propertyPath]
   * @returns { TodoToggleItemParams}
   */
  toggleItemParams: (value, propertyPath = "$") => {
    let result = value;
    if ("preValidateTodoToggleItemParams" in validatorHooks) {
      result = validatorHooks["preValidateTodoToggleItemParams"](result);
    }
    result = objectValidator26(result, propertyPath);
    if ("postValidateTodoToggleItemParams" in validatorHooks) {
      return validatorHooks["postValidateTodoToggleItemParams"](result);
    }
    return result;
  },

  /**
   *
   * @param {*} value
   * @param {string} [propertyPath]
   * @returns { TodoToggleItemResponse}
   */
  toggleItemResponse: (value, propertyPath = "$") => {
    let result = value;
    if ("preValidateTodoToggleItemResponse" in validatorHooks) {
      result = validatorHooks["preValidateTodoToggleItemResponse"](result);
    }
    result = objectValidator27(result, propertyPath);
    if ("postValidateTodoToggleItemResponse" in validatorHooks) {
      return validatorHooks["postValidateTodoToggleItemResponse"](result);
    }
    return result;
  },
};

function anyValidator0(
  value,
  propertyPath,
  errorList = [],
  parentType = "any",
) {
  if (isNil(value)) {
    return buildError("validator.any.undefined", { propertyPath }, errorList);
  }
  return value;
}
function referenceValidator2(
  value,
  propertyPath,
  errorList = [],
  parentType = "reference",
) {
  if (isNil(value)) {
    return buildError(
      "validator.reference.undefined",
      { propertyPath },
      errorList,
    );
  }
  return todoValidators.collection(value, propertyPath);
}
function objectValidator1(
  value,
  propertyPath,
  errorList = [],
  parentType = "object",
) {
  if (isNil(value)) {
    return buildError(
      "validator.object.undefined",
      { propertyPath },
      errorList,
    );
  }
  if (typeof value !== "object") {
    return buildError(
      `validator.${parentType}.type`,
      { propertyPath },
      errorList,
    );
  }
  const result = Object.create(null);
  const keySet = new Set(Object.keys(value));
  result["store"] = referenceValidator2(
    value["store"],
    `${propertyPath}.` + `store`,
    errorList,
  );
  keySet.delete("store");
  if (keySet.size !== 0) {
    let extraKeys = "";
    for (const k of keySet.keys()) {
      extraKeys += `${k},`;
    }
    return buildError(
      `validator.${parentType}.strict`,
      { propertyPath, extraKeys },
      errorList,
    );
  }
  return result;
}
function stringValidator4(
  value,
  propertyPath,
  errorList = [],
  parentType = "string",
) {
  if (isNil(value)) {
    return buildError(
      "validator.string.undefined",
      { propertyPath },
      errorList,
    );
  }
  if (typeof value !== "string") {
    return buildError(
      `validator.${parentType}.type`,
      { propertyPath },
      errorList,
    );
  }
  if (value.length < 1) {
    const min = 1;
    return buildError(
      `validator.${parentType}.min`,
      { propertyPath, min },
      errorList,
    );
  }
  return value;
}
function referenceValidator5(
  value,
  propertyPath,
  errorList = [],
  parentType = "reference",
) {
  if (isNil(value)) {
    return buildError(
      "validator.reference.undefined",
      { propertyPath },
      errorList,
    );
  }
  return todoValidators.list(value, propertyPath);
}
function genericValidator3(
  value,
  propertyPath,
  errorList = [],
  parentType = "generic",
) {
  if (isNil(value)) {
    return buildError(
      "validator.generic.undefined",
      { propertyPath },
      errorList,
    );
  }
  if (typeof value !== "object") {
    return buildError(
      `validator.${parentType}.type`,
      { propertyPath },
      errorList,
    );
  }
  const result = Object.create(null);
  for (const key of Object.keys(value)) {
    const validatedKey = stringValidator4(
      key,
      `${propertyPath}.$key[${key}]`,
      errorList,
    );
    result[validatedKey] = referenceValidator5(
      value[key],
      `${propertyPath}.$value[${key}]`,
      errorList,
    );
  }
  return result;
}
function stringValidator7(
  value,
  propertyPath,
  errorList = [],
  parentType = "string",
) {
  if (isNil(value)) {
    return buildError(
      "validator.string.undefined",
      { propertyPath },
      errorList,
    );
  }
  if (typeof value !== "string") {
    return buildError(
      `validator.${parentType}.type`,
      { propertyPath },
      errorList,
    );
  }
  value = value.trim();
  if (value.length < 1) {
    const min = 1;
    return buildError(
      `validator.${parentType}.min`,
      { propertyPath, min },
      errorList,
    );
  }
  if (value.length > 365) {
    const max = 365;
    return buildError(
      `validator.${parentType}.max`,
      { propertyPath, max },
      errorList,
    );
  }
  return value;
}
function objectValidator6(
  value,
  propertyPath,
  errorList = [],
  parentType = "object",
) {
  if (isNil(value)) {
    return buildError(
      "validator.object.undefined",
      { propertyPath },
      errorList,
    );
  }
  if (typeof value !== "object") {
    return buildError(
      `validator.${parentType}.type`,
      { propertyPath },
      errorList,
    );
  }
  const result = Object.create(null);
  const keySet = new Set(Object.keys(value));
  result["name"] = stringValidator7(
    value["name"],
    `${propertyPath}.` + `name`,
    errorList,
  );
  keySet.delete("name");
  if (keySet.size !== 0) {
    let extraKeys = "";
    for (const k of keySet.keys()) {
      extraKeys += `${k},`;
    }
    return buildError(
      `validator.${parentType}.strict`,
      { propertyPath, extraKeys },
      errorList,
    );
  }
  return result;
}
function stringValidator9(
  value,
  propertyPath,
  errorList = [],
  parentType = "string",
) {
  if (isNil(value)) {
    return buildError(
      "validator.string.undefined",
      { propertyPath },
      errorList,
    );
  }
  if (typeof value !== "string") {
    return buildError(
      `validator.${parentType}.type`,
      { propertyPath },
      errorList,
    );
  }
  value = value.trim();
  if (value.length < 1) {
    const min = 1;
    return buildError(
      `validator.${parentType}.min`,
      { propertyPath, min },
      errorList,
    );
  }
  if (value.length > 30) {
    const max = 30;
    return buildError(
      `validator.${parentType}.max`,
      { propertyPath, max },
      errorList,
    );
  }
  return value;
}
function objectValidator8(
  value,
  propertyPath,
  errorList = [],
  parentType = "object",
) {
  if (isNil(value)) {
    return buildError(
      "validator.object.undefined",
      { propertyPath },
      errorList,
    );
  }
  if (typeof value !== "object") {
    return buildError(
      `validator.${parentType}.type`,
      { propertyPath },
      errorList,
    );
  }
  const result = Object.create(null);
  const keySet = new Set(Object.keys(value));
  result["name"] = stringValidator9(
    value["name"],
    `${propertyPath}.` + `name`,
    errorList,
  );
  keySet.delete("name");
  if (keySet.size !== 0) {
    let extraKeys = "";
    for (const k of keySet.keys()) {
      extraKeys += `${k},`;
    }
    return buildError(
      `validator.${parentType}.strict`,
      { propertyPath, extraKeys },
      errorList,
    );
  }
  return result;
}
function objectValidator10(
  value,
  propertyPath,
  errorList = [],
  parentType = "object",
) {
  if (isNil(value)) {
    return buildError(
      "validator.object.undefined",
      { propertyPath },
      errorList,
    );
  }
  if (typeof value !== "object") {
    return buildError(
      `validator.${parentType}.type`,
      { propertyPath },
      errorList,
    );
  }
  const result = Object.create(null);
  const keySet = new Set(Object.keys(value));
  result["todo"] = referenceValidator5(
    value["todo"],
    `${propertyPath}.` + `todo`,
    errorList,
  );
  keySet.delete("todo");
  if (keySet.size !== 0) {
    let extraKeys = "";
    for (const k of keySet.keys()) {
      extraKeys += `${k},`;
    }
    return buildError(
      `validator.${parentType}.strict`,
      { propertyPath, extraKeys },
      errorList,
    );
  }
  return result;
}
function objectValidator11(
  value,
  propertyPath,
  errorList = [],
  parentType = "object",
) {
  if (isNil(value)) {
    return buildError(
      "validator.object.undefined",
      { propertyPath },
      errorList,
    );
  }
  if (typeof value !== "object") {
    return buildError(
      `validator.${parentType}.type`,
      { propertyPath },
      errorList,
    );
  }
  const result = Object.create(null);
  const keySet = new Set(Object.keys(value));
  result["name"] = stringValidator9(
    value["name"],
    `${propertyPath}.` + `name`,
    errorList,
  );
  keySet.delete("name");
  if (keySet.size !== 0) {
    let extraKeys = "";
    for (const k of keySet.keys()) {
      extraKeys += `${k},`;
    }
    return buildError(
      `validator.${parentType}.strict`,
      { propertyPath, extraKeys },
      errorList,
    );
  }
  return result;
}
function booleanValidator13(
  value,
  propertyPath,
  errorList = [],
  parentType = "boolean",
) {
  if (isNil(value)) {
    return buildError(
      "validator.boolean.undefined",
      { propertyPath },
      errorList,
    );
  }
  if (typeof value !== "boolean") {
    return buildError(
      `validator.${parentType}.type`,
      { propertyPath },
      errorList,
    );
  }
  if (value !== true) {
    const oneOf = true;
    return buildError(
      `validator.${parentType}.oneOf`,
      { propertyPath, oneOf },
      errorList,
    );
  }
  return value;
}
function objectValidator12(
  value,
  propertyPath,
  errorList = [],
  parentType = "object",
) {
  if (isNil(value)) {
    return buildError(
      "validator.object.undefined",
      { propertyPath },
      errorList,
    );
  }
  if (typeof value !== "object") {
    return buildError(
      `validator.${parentType}.type`,
      { propertyPath },
      errorList,
    );
  }
  const result = Object.create(null);
  const keySet = new Set(Object.keys(value));
  result["deleted"] = booleanValidator13(
    value["deleted"],
    `${propertyPath}.` + `deleted`,
    errorList,
  );
  keySet.delete("deleted");
  if (keySet.size !== 0) {
    let extraKeys = "";
    for (const k of keySet.keys()) {
      extraKeys += `${k},`;
    }
    return buildError(
      `validator.${parentType}.strict`,
      { propertyPath, extraKeys },
      errorList,
    );
  }
  return result;
}
function booleanValidator15(
  value,
  propertyPath,
  errorList = [],
  parentType = "boolean",
) {
  if (isNil(value)) {
    return false;
  }
  if (typeof value !== "boolean") {
    return buildError(
      `validator.${parentType}.type`,
      { propertyPath },
      errorList,
    );
  }
  return value;
}
function objectValidator14(
  value,
  propertyPath,
  errorList = [],
  parentType = "object",
) {
  if (isNil(value)) {
    return buildError(
      "validator.object.undefined",
      { propertyPath },
      errorList,
    );
  }
  if (typeof value !== "object") {
    return buildError(
      `validator.${parentType}.type`,
      { propertyPath },
      errorList,
    );
  }
  const result = Object.create(null);
  const keySet = new Set(Object.keys(value));
  result["completed"] = booleanValidator15(
    value["completed"],
    `${propertyPath}.` + `completed`,
    errorList,
  );
  keySet.delete("completed");
  result["name"] = stringValidator4(
    value["name"],
    `${propertyPath}.` + `name`,
    errorList,
  );
  keySet.delete("name");
  if (keySet.size !== 0) {
    let extraKeys = "";
    for (const k of keySet.keys()) {
      extraKeys += `${k},`;
    }
    return buildError(
      `validator.${parentType}.strict`,
      { propertyPath, extraKeys },
      errorList,
    );
  }
  return result;
}
function referenceValidator18(
  value,
  propertyPath,
  errorList = [],
  parentType = "reference",
) {
  if (isNil(value)) {
    return buildError(
      "validator.reference.undefined",
      { propertyPath },
      errorList,
    );
  }
  return todoValidators.item(value, propertyPath);
}
function arrayValidator17(
  value,
  propertyPath,
  errorList = [],
  parentType = "array",
) {
  if (isNil(value)) {
    return buildError("validator.array.undefined", { propertyPath }, errorList);
  }
  if (!Array.isArray(value)) {
    return buildError(
      `validator.${parentType}.type`,
      { propertyPath },
      errorList,
    );
  }
  const result = [];
  for (let i = 0; i < value.length; ++i) {
    result.push(
      referenceValidator18(value[i], `${propertyPath}[${i}]`, errorList),
    );
  }
  return result;
}
function objectValidator16(
  value,
  propertyPath,
  errorList = [],
  parentType = "object",
) {
  if (isNil(value)) {
    return buildError(
      "validator.object.undefined",
      { propertyPath },
      errorList,
    );
  }
  if (typeof value !== "object") {
    return buildError(
      `validator.${parentType}.type`,
      { propertyPath },
      errorList,
    );
  }
  const result = Object.create(null);
  const keySet = new Set(Object.keys(value));
  result["name"] = stringValidator4(
    value["name"],
    `${propertyPath}.` + `name`,
    errorList,
  );
  keySet.delete("name");
  result["items"] = arrayValidator17(
    value["items"],
    `${propertyPath}.` + `items`,
    errorList,
  );
  keySet.delete("items");
  if (keySet.size !== 0) {
    let extraKeys = "";
    for (const k of keySet.keys()) {
      extraKeys += `${k},`;
    }
    return buildError(
      `validator.${parentType}.strict`,
      { propertyPath, extraKeys },
      errorList,
    );
  }
  return result;
}
function objectValidator19(
  value,
  propertyPath,
  errorList = [],
  parentType = "object",
) {
  if (isNil(value)) {
    return buildError(
      "validator.object.undefined",
      { propertyPath },
      errorList,
    );
  }
  if (typeof value !== "object") {
    return buildError(
      `validator.${parentType}.type`,
      { propertyPath },
      errorList,
    );
  }
  const result = Object.create(null);
  const keySet = new Set(Object.keys(value));
  result["name"] = stringValidator9(
    value["name"],
    `${propertyPath}.` + `name`,
    errorList,
  );
  keySet.delete("name");
  if (keySet.size !== 0) {
    let extraKeys = "";
    for (const k of keySet.keys()) {
      extraKeys += `${k},`;
    }
    return buildError(
      `validator.${parentType}.strict`,
      { propertyPath, extraKeys },
      errorList,
    );
  }
  return result;
}
function referenceValidator21(
  value,
  propertyPath,
  errorList = [],
  parentType = "reference",
) {
  if (isNil(value)) {
    return buildError(
      "validator.reference.undefined",
      { propertyPath },
      errorList,
    );
  }
  return todoValidators.list(value, propertyPath);
}
function objectValidator20(
  value,
  propertyPath,
  errorList = [],
  parentType = "object",
) {
  if (isNil(value)) {
    return buildError(
      "validator.object.undefined",
      { propertyPath },
      errorList,
    );
  }
  if (typeof value !== "object") {
    return buildError(
      `validator.${parentType}.type`,
      { propertyPath },
      errorList,
    );
  }
  const result = Object.create(null);
  const keySet = new Set(Object.keys(value));
  result["todo"] = referenceValidator21(
    value["todo"],
    `${propertyPath}.` + `todo`,
    errorList,
  );
  keySet.delete("todo");
  if (keySet.size !== 0) {
    let extraKeys = "";
    for (const k of keySet.keys()) {
      extraKeys += `${k},`;
    }
    return buildError(
      `validator.${parentType}.strict`,
      { propertyPath, extraKeys },
      errorList,
    );
  }
  return result;
}
function objectValidator22(
  value,
  propertyPath,
  errorList = [],
  parentType = "object",
) {
  if (isNil(value)) {
    return buildError(
      "validator.object.undefined",
      { propertyPath },
      errorList,
    );
  }
  if (typeof value !== "object") {
    return buildError(
      `validator.${parentType}.type`,
      { propertyPath },
      errorList,
    );
  }
  const result = Object.create(null);
  const keySet = new Set(Object.keys(value));
  result["name"] = stringValidator9(
    value["name"],
    `${propertyPath}.` + `name`,
    errorList,
  );
  keySet.delete("name");
  if (keySet.size !== 0) {
    let extraKeys = "";
    for (const k of keySet.keys()) {
      extraKeys += `${k},`;
    }
    return buildError(
      `validator.${parentType}.strict`,
      { propertyPath, extraKeys },
      errorList,
    );
  }
  return result;
}
function objectValidator23(
  value,
  propertyPath,
  errorList = [],
  parentType = "object",
) {
  if (isNil(value)) {
    return buildError(
      "validator.object.undefined",
      { propertyPath },
      errorList,
    );
  }
  if (typeof value !== "object") {
    return buildError(
      `validator.${parentType}.type`,
      { propertyPath },
      errorList,
    );
  }
  const result = Object.create(null);
  const keySet = new Set(Object.keys(value));
  result["todo"] = referenceValidator21(
    value["todo"],
    `${propertyPath}.` + `todo`,
    errorList,
  );
  keySet.delete("todo");
  if (keySet.size !== 0) {
    let extraKeys = "";
    for (const k of keySet.keys()) {
      extraKeys += `${k},`;
    }
    return buildError(
      `validator.${parentType}.strict`,
      { propertyPath, extraKeys },
      errorList,
    );
  }
  return result;
}
function numberValidator25(
  value,
  propertyPath,
  errorList = [],
  parentType = "number",
) {
  if (isNil(value)) {
    return buildError(
      "validator.number.undefined",
      { propertyPath },
      errorList,
    );
  }
  if (typeof value !== "number") {
    value = Number(value);
  }
  if (typeof value !== "number" || isNaN(value) || !isFinite(value)) {
    return buildError(
      `validator.${parentType}.type`,
      { propertyPath },
      errorList,
    );
  }
  if (!Number.isInteger(value)) {
    return buildError(
      `validator.${parentType}.integer`,
      { propertyPath },
      errorList,
    );
  }
  if (value < 0) {
    const min = 0;
    return buildError(
      `validator.${parentType}.min`,
      { propertyPath, min },
      errorList,
    );
  }
  return value;
}
function objectValidator24(
  value,
  propertyPath,
  errorList = [],
  parentType = "object",
) {
  if (isNil(value)) {
    return buildError(
      "validator.object.undefined",
      { propertyPath },
      errorList,
    );
  }
  if (typeof value !== "object") {
    return buildError(
      `validator.${parentType}.type`,
      { propertyPath },
      errorList,
    );
  }
  const result = Object.create(null);
  const keySet = new Set(Object.keys(value));
  result["index"] = numberValidator25(
    value["index"],
    `${propertyPath}.` + `index`,
    errorList,
  );
  keySet.delete("index");
  if (keySet.size !== 0) {
    let extraKeys = "";
    for (const k of keySet.keys()) {
      extraKeys += `${k},`;
    }
    return buildError(
      `validator.${parentType}.strict`,
      { propertyPath, extraKeys },
      errorList,
    );
  }
  return result;
}
function objectValidator26(
  value,
  propertyPath,
  errorList = [],
  parentType = "object",
) {
  if (isNil(value)) {
    return buildError(
      "validator.object.undefined",
      { propertyPath },
      errorList,
    );
  }
  if (typeof value !== "object") {
    return buildError(
      `validator.${parentType}.type`,
      { propertyPath },
      errorList,
    );
  }
  const result = Object.create(null);
  const keySet = new Set(Object.keys(value));
  result["name"] = stringValidator9(
    value["name"],
    `${propertyPath}.` + `name`,
    errorList,
  );
  keySet.delete("name");
  if (keySet.size !== 0) {
    let extraKeys = "";
    for (const k of keySet.keys()) {
      extraKeys += `${k},`;
    }
    return buildError(
      `validator.${parentType}.strict`,
      { propertyPath, extraKeys },
      errorList,
    );
  }
  return result;
}
function objectValidator27(
  value,
  propertyPath,
  errorList = [],
  parentType = "object",
) {
  if (isNil(value)) {
    return buildError(
      "validator.object.undefined",
      { propertyPath },
      errorList,
    );
  }
  if (typeof value !== "object") {
    return buildError(
      `validator.${parentType}.type`,
      { propertyPath },
      errorList,
    );
  }
  const result = Object.create(null);
  const keySet = new Set(Object.keys(value));
  result["todo"] = referenceValidator21(
    value["todo"],
    `${propertyPath}.` + `todo`,
    errorList,
  );
  keySet.delete("todo");
  if (keySet.size !== 0) {
    let extraKeys = "";
    for (const k of keySet.keys()) {
      extraKeys += `${k},`;
    }
    return buildError(
      `validator.${parentType}.strict`,
      { propertyPath, extraKeys },
      errorList,
    );
  }
  return result;
}
